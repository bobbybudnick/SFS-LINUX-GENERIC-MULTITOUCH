#!/bin/bash

#Multitouch Methods For Generic X11 Applications
#by Bobby Budnick

#required software - xdotool/evtest/bc and others

#a little more explanation - for update 1
#a first and second touch will be detected on the first touch
#this is because catch and catch store will never perfectly match
#still should work though
#this is because it is set to watch for subsequent moves
#these moves will not be watched once first finger is released
#this is because releasing generates a -1 which resets script
#also second touches while first held down do not generate -1
#these observations only apply to the waveshare 5" for now

#a little more explanation - further simplified - for update 2
#check for first touch hold
#while first touch held check for first touch release and reset
#while first touch held check for second touch or mouse movement caused by second touch and send click to second touch coordinates but do not reset

#clear virtual file
truncate -s 0 /run/user/1000/TOUCH_OUTPUT

#try to figure out which touch device to use
#support not added for waveshare 4.3" because it does not work
sudo rm /home/pi/EVTEST_DEVICE
#none of these work
#EVTEST_DEVICE_CAPTURE=$(sudo evtest 2>&1)&
#sudo evtest > /home/pi/EVTEST_DEVICE&
#sudo evtest 2>&1 /home/pi/EVTEST_DEVICE
script -c 'sudo evtest' /home/pi/EVTEST_DEVICE&
sleep 1
sudo killall evtest
sleep 1
DEVICE_GUESS_1=$(cat /home/pi/EVTEST_DEVICE | grep Touch | cut -d":" -f1 | cut -c17-25)
if [ $DEVICE_GUESS_1 -gt 0 ]
then
DEVICE_GUESS=$DEVICE_GUESS_1
fi
DEVICE_GUESS_2=$(cat /home/pi/EVTEST_DEVICE | grep WaveShare | cut -d":" -f1 | cut -c17-25)
if [ $DEVICE_GUESS_2 -gt 0 ]
then
DEVICE_GUESS=$DEVICE_GUESS_2
fi
#DEVICE_GUESS=$(xinput list | grep Touch | cut -d"=" -f2 | cut -c1-3)
DEVICE_GUESS_FAILSAFE=$(echo $DEVICE_GUESS | wc -l)
if [ $DEVICE_GUESS_FAILSAFE -lt 1 ]
then
kdialog --msgbox "No Multitouch Devices Found!"
echo "No Multitouch Devices Found!"
#porting cue - remove this exit if you have hacked the evtest line below
exit
fi

#start evtest with guessed device so touch events are monitored
#porting cue - replace with true device number
sudo evtest /dev/input/event$DEVICE_GUESS > /run/user/1000/TOUCH_OUTPUT&

#initial variables
ID_CATCH_STORE=-100
#MOVEMENT_CATCH_STORE=0

#cut does not work when grepping directly from program xinput
#should run program then cat from output instead

while [ true ]
do

#watch for a new tracking id
#the awk here filters all results that are less than 0
ID_CATCH_1=$(cat /run/user/1000/TOUCH_OUTPUT | grep -a ABS_MT_TRACKING_ID | cut -d" " -f11 | awk ' $0 > 0 ' | tail -n1)
	#make sure this is a new event to keep from repeating
	if [ $ID_CATCH_1 -gt $ID_CATCH_STORE ] 2>/dev/null
	then

	ID_CATCH_STORE=$ID_CATCH_1
	#update 2 - be sure to store initial x coordinate here so the if statement below does not fire for no reason
	MOVEMENT_CATCH_STORE=$(cat /run/user/1000/TOUCH_OUTPUT | grep -a ABS_MT_POSITION_X | tail -n1 | cut -d" " -f11)

	echo "First Move Detected"
	MOVE_TRACKING=1
		while [ "$MOVE_TRACKING" -eq "1" ]
		do

		#watch for a negative tracking id
		#this indicates that a finger has been released
		#this means it is time to reset and watch again
		#as mentioned before a negative tracking id should not be generated by second presses until the first is released
		#so the loop should continue until the first finger press is released
		#the awk here filters all results that are greater than 0
		NEGATIVE_CATCH=$(cat /run/user/1000/TOUCH_OUTPUT | grep -a ABS_MT_TRACKING_ID | cut -d" " -f11 | awk ' $0 < 0 ' | tail -n1)
		#could also count and use wc -l here
			if [ $NEGATIVE_CATCH -lt 0 ] 2>/dev/null
			then
			echo "Finger Release"
			MOVE_TRACKING=0
			#exit loop and clear virtual file
			#no way to tell one -1 from another
			truncate -s 0 /run/user/1000/TOUCH_OUTPUT
			fi

		#watch for a second tracking id
		#this apppears when touched with other finger
		ID_CATCH_2=$(cat /run/user/1000/TOUCH_OUTPUT | grep -a ABS_MT_TRACKING_ID | cut -d" " -f11 | awk ' $0 > 0 ' | tail -n1)

		#watch for generic movement - x coordinate used
		#any moves across screen picked up here
		#subsequent presses picked up here also
		MOVEMENT_CATCH=$(cat /run/user/1000/TOUCH_OUTPUT | grep -a ABS_MT_POSITION_X | tail -n1 | cut -d" " -f11)

			#for debugging if statement below
			#if [ $ID_CATCH_2 -gt $ID_CATCH_1 ]
			#then
			#echo "ID CHECK - DEBUG"
			#fi
			#if [ $MOVEMENT_CATCH -gt $(expr $MOVEMENT_CATCH_STORE + 0) ] || [ $MOVEMENT_CATCH -lt $(expr $MOVEMENT_CATCH_STORE - 0) ]
			#then
			#echo "MOVEMENT CHECK - DEBUG"
			#fi
			
			#for debugging touch confusion
			#echo "Movement Catch Store: $MOVEMENT_CATCH_STORE"
			#echo "Movement Catch: $MOVEMENT_CATCH"
			#sleep 500

			#update 2 - if a second touch happens while the first touch is held or if there is any x mouse movement while the first touch is held then fire
			#if the id is greater then we have touched the screen a second time
			#this is because a new id is created and is always (hopefully) larger
			#could put a /dev/null on this but it would be confusing if something really did go wrong
			#this is an or
			#also checks subsequent presses with the second part of the if statement
			#subsequent presses do not generate a new id
			#this compares the subsequent touched area with the previous subsequently touched area
			#this seems to work because subsequent touches are usually not pixel accurate
			#it will not fire if your dexterity is so high that you always touch the exact same spot
			#luckily most people are not and the overlay buttons are many pixels across
			if [ $ID_CATCH_2 -gt $ID_CATCH_1 ] || [ $MOVEMENT_CATCH -ne $MOVEMENT_CATCH_STORE ]
			#if [ $ID_CATCH_2 -gt $ID_CATCH_1 ] || [ $MOVEMENT_CATCH -gt $(expr $MOVEMENT_CATCH_STORE + 0) ] || [ $MOVEMENT_CATCH -lt $(expr $MOVEMENT_CATCH_STORE - 0) ]
			then

			echo "Second Move Detected"
			#very important to avoid repeats
			ID_CATCH_1=$ID_CATCH_2
			MOVEMENT_CATCH_STORE=$MOVEMENT_CATCH

			#grep is broken without the "a" switch
			#X_COORDINATE=$(cat /run/user/1000/TOUCH_OUTPUT | grep -a ABS_MT_POSITION_X | tail -n1 | cut -d" " -f11)
			#Y_COORDINATE_PRE_1=$(cat /run/user/1000/TOUCH_OUTPUT | grep -a ABS_MT_POSITION_Y | tail -n1 | cut -d" " -f11)
			#Y_COORDINATE_PRE_2=$(expr $Y_COORDINATE_PRE_1 - 480)
			#Y_COORDINATE=$(echo $Y_COORDINATE_PRE_2 | tr -d -)
            #Y_COORDINATE=$(cat /run/user/1000/TOUCH_OUTPUT | grep -a ABS_MT_POSITION_Y | tail -n1 | cut -d" " -f11)

            #find the x and y coordinates of the touch
            #ABS_MT_POSITION_X and Y are reversed from what is intuitive
            #800x480 seems to be the resolution evtest is referencing
            #xdotool starts with 0/0 in upper left
            #evtest starts with 0/800 in upper left
            #get raw evtest x coordinate value
            X_COORDINATE_PRE_1=$(cat /run/user/1000/TOUCH_OUTPUT | grep -a ABS_MT_POSITION_Y | tail -n1 | cut -d" " -f11)
            #720 current width is 1.5 times apparent 480 evtest reference width
            #porting cue - replace with base to curremt resolution x scale factor
            X_COORDINATE=$(echo "$X_COORDINATE_PRE_1*1.5" | bc)
            #get raw evtest y coordinate value
            Y_COORDINATE_PRE_1=$(cat /run/user/1000/TOUCH_OUTPUT | grep -a ABS_MT_POSITION_X | tail -n1 | cut -d" " -f11)
            #subtract evtest reference screen height
            #porting cue - replace with evtest max vertical resolution
            Y_COORDINATE_PRE_2=$(expr $Y_COORDINATE_PRE_1 - 800)
            #get the absolute value
            Y_COORDINATE_PRE_3=$(echo $Y_COORDINATE_PRE_2 | tr -d -)
            #1280 current height is 1.6 times apparent 800 evtest reference width
            #porting cue - replace with base to curremt resolution y scale factor
            Y_COORDINATE=$(echo "$Y_COORDINATE_PRE_3*1.6" | bc)
			#echo "X:$X_COORDINATE Y:$Y_COORDINATE"
			#sleep 500


            #send coordinates to xdotool and execute
			#the restore was crucial here to prevent the left thumb (first input) from stopping
			#xdotool mousemove $Y_COORDINATE $X_COORDINATE click 1 mousemove restore
            #xdotool mousemove $X_COORDINATE $Y_COORDINATE click 1 mousemove restore
            #does not seem to work now without a double click - this works in kde
            #xdotool mousemove $X_COORDINATE $Y_COORDINATE click --repeat 2 1
            #does not register on overlay without mousedown
            #restore is not restoring the previous position with mousedown
            #xdotool mousemove $X_COORDINATE $Y_COORDINATE mousedown 1 restore
            #many repeats instead of mousedown not working
            #xdotool mousemove $X_COORDINATE $Y_COORDINATE click --repeat 10 1
            #grab the first mouse location
			#hack to keep input working on first input after semding second input
			MOUSE_LOCATION=$(xdotool getmouselocation)
            #move to second location
            xdotool mousemove $X_COORDINATE $Y_COORDINATE mousedown 1
            #derive the original x and y
            ORIGINAL_X=$(echo $MOUSE_LOCATION | cut -d" " -f1 | cut -d":" -f2)
            ORIGINAL_Y=$(echo $MOUSE_LOCATION | cut -d" " -f2 | cut -d":" -f2)
            #echo "X:$ORIGINAL_X Y:$ORIGINAL_Y"
            #echo $MOUSE_LOCATION
            #keep mario from jumping short
            sleep 0.1
            #move back to first location
            #again this should keep the first input from stopping
            xdotool mousemove $ORIGINAL_X $ORIGINAL_Y
            #sleep 500
            
			fi

		sleep .1
		done

	fi

sleep .1
done

